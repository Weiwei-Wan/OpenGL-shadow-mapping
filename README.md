# OpenGL-shadow-mapping
CS7GV3 Research Implementation 

In the real world, shadow is a dark area where light from a light source is blocked by an object. In 3D computer graphics, shadow mapping is a process by which shadows are added to the computer rendering world. Here I introduced a state of art shadow mapping technology moment shadow mapping, and I also compared this method with previous methods including basic shadow mapping, shadow mapping with bias, percentage closer filtering, percentage closer soft shadow, and variance soft shadow mapping. There are many other shadow mapping techniques that have been developed, each with their own strengths and weaknesses. The choice of which method to use will depend on the specific requirements of the application, such as performance, quality, and visual style

1. Basic shadow mapping
To implement shadow mapping, first a depth texture or a depth buffer is created to store the depth values of the scene from the perspective of the light source. This is typically done by rendering the scene from the point of view of the light source and storing the depth values in a texture.
The depth texture is then used to create a shadow map, which is a 2D texture that represents the scene from the perspective of the light source. This involves rendering the scene again, this time from the point of view of the camera, and comparing the depth values of the rendered pixels with those stored in the depth texture. If the rendered pixel is farther from the light source than the corresponding depth value in the depth texture, then it is in shadow.
Once the shadow map is created, it can be applied to the scene to produce realistic-looking shadows. When rendering a pixel, the distance from the pixel to the light source is compared to the depth values in the shadow map. If the pixel is in shadow, then the diffuse and specular lighting calculations are skipped and the pixel is shaded using only the ambient lighting. The implementation of basic shadowing mapping in my scene is shown below.

![image](https://github.com/Weiwei-Wan/OpenGL-shadow-mapping/assets/74362292/11b314c9-4056-4e8e-b73f-90801d46c14a)

3. Basic shadow mapping with bias
When implementing shadow mapping, aliasing artifacts can occur due to the limited resolution of the shadow map as shown above. These artifacts can be reduced by adding a bias value to the depth comparison test. The bias value is a small value added to the depth value in the shadow map comparison to ensure that the depth test passes even if the rendered pixel is slightly offset from the actual surface. After adding bias, the stripes disappear and the scene is shown below.

![image](https://github.com/Weiwei-Wan/OpenGL-shadow-mapping/assets/74362292/42a37e4b-2425-4699-9a18-b6e0ddd35db3)

5. Percentage Closer Filtering (PCF) 
PCF is a technique used to reduce the aliasing artifacts in shadow mapping by taking multiple samples from the shadow map and averaging the results. To implement PCF, first we need to calculate the offset for each sample, the offset is based on the size of the shadow map and the radius. Then we need to calculate the shadow factor for each sample, the distance from the pixel being rendered to the light source is compared to the depth value in the shadow map at the sample position. If the distance is less than the depth value, then the pixel is in shadow and the shadow factor for the sample is set to 1. Otherwise, the shadow factor is set to 0. At last the shadow factors for each sample are averaged to obtain a final shadow factor for the pixel being rendered and we can apply shadow to my scene as shown below, the edge is softer than basic shadow mapping. However, PCF might be computationally expensive, especially with a large number of samples.

![image](https://github.com/Weiwei-Wan/OpenGL-shadow-mapping/assets/74362292/a23df898-27bf-41eb-bf06-adc506fa91b6)

7. Percentage Closer Soft Shadow (PCSS)
PCSS is an extension of PCF that allows for the creation of soft shadows by blurring the edges of the shadow. To implement PCSS, after we calculated the shadow factor for samples, we need to calculate the blocker search radius, the distance from the pixel being rendered to the nearest occluder, which is the surface that is blocking the light from the light source. This distance can be calculated by comparing the distance from the pixel to the light source with the depth values in the shadow map. Then we need to calculate the size of the blurred shadow edge, penumbra size, it's calculated based on the blocker search radius and the light source size. Then we need to determine how much the shadow factor should be blurred based on the distance from the pixel to the occluder and the penumbra size and blur the shadow factor. At last we can apply shadow to my scene as shown below, the shadow close to the blocker is harder and far away to the blocker is softer.

![image](https://github.com/Weiwei-Wan/OpenGL-shadow-mapping/assets/74362292/5ced21f3-988a-4371-bea6-53abe8b9c425)

9. Variance Soft Shadow Mapping (VSSM)
To implement Variance Soft Shadow Mapping, after we get the depth texture and a shadow map, we need to calculate the depth variance for each pixel, it’s the difference between the depth value of the pixel and the average depth value of the surrounding pixels, and we generated a variance map. Then we calculate the penumbra size and blur the depth variance, the amount of blur applied should be proportional to the penumbra size. Then we need to calculate the shadow factor by comparing the depth value of the pixel being rendered to the depth value in the shadow map at the same position. If the depth value is less than the depth value in the shadow map minus the depth variance, then the pixel is in shadow. At last we can apply shadow to my scene as shown below. However, light leaking is a common artifact that can occur with VSSM, it happens when some areas that should be in shadow appear partially or fully lit, and it’s also shown below.

![image](https://github.com/Weiwei-Wan/OpenGL-shadow-mapping/assets/74362292/c0288c5e-1bb5-49b7-b6a4-d8fb0d4f1e60)

11. Moment Shadow Mapping (MSM)
​​To implement Moment Shadow Mapping, after we get the depth texture and a shadow map, we need to calculate the moments of the depth values, for each pixel in the shadow map, the depth value and its powers are calculated up to a certain order. Then we calculate the central moments of the depth values, the central moments are calculated from the raw moments using standard formulas, and the second-order central moments are used to estimate the size and orientation of the occluder. Then a set of basis functions were generated by sampling the distance from the pixel being rendered to the nearest occluder along several directions. Then the shadow factor for each pixel can be estimated by projecting the basis functions onto the occluder and integrating over the surface. At last we can apply shadow to my scene as shown below.

![image](https://github.com/Weiwei-Wan/OpenGL-shadow-mapping/assets/74362292/ed15fe70-0423-48eb-bac4-5750a1f1f01a)

The basic shadow mapping technique involves rendering the scene from the perspective of the light source and generating a depth map to determine which parts of the scene are in shadow. However, aliasing artifacts and self-shadowing can occur, which can be resolved by adding bias to the depth comparison in the shadow mapping. PCF is a technique used to improve the quality of shadows by taking multiple depth samples from the shadow map and averaging them to obtain a smoother shadow boundary. PCSS combines PCF with soft shadows to produce high-quality, soft-edged shadows with accurate penumbra regions. VSSM is a computationally efficient technique that stores the mean and mean squared of a distribution of depths, and then computes the variance over any filter region. This technique solves the problem of shadow map aliasing with minimal additional storage and computation. However, light leaking is a common artifact that can occur with VSSM, and MSM could solve this problem. The choice of which method to use depends on the specific requirements of the application, such as performance, quality, and visual style. Overall, these techniques enable realistic, high-quality shadow rendering in 3D computer graphics.

Youtube link: https://www.youtube.com/watch?v=qBunQflV1aY
